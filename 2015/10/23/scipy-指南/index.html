<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>scipy-指南 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="scipy原文 : https://uqer.io/community/share/54d83bb3f9f06c276f651a6e
NumPy替我们搞定了向量和矩阵的相关操作，基本上算是一个高级的科学计算器。SciPy基于NumPy提供了更为丰富和高级的功能扩展，在统计、优化、插值、数值积分、时频转换等方面提供了大量的可用函数，基本覆盖了基础科学计算相关的问题。
在量化分析中，运用最广泛的是统计">
<meta property="og:type" content="article">
<meta property="og:title" content="scipy-指南">
<meta property="og:url" content="http://yoursite.com/2015/10/23/scipy-指南/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="scipy原文 : https://uqer.io/community/share/54d83bb3f9f06c276f651a6e
NumPy替我们搞定了向量和矩阵的相关操作，基本上算是一个高级的科学计算器。SciPy基于NumPy提供了更为丰富和高级的功能扩展，在统计、优化、插值、数值积分、时频转换等方面提供了大量的可用函数，基本覆盖了基础科学计算相关的问题。
在量化分析中，运用最广泛的是统计">
<meta property="og:updated_time" content="2015-11-06T08:34:21.228Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="scipy-指南">
<meta name="twitter:description" content="scipy原文 : https://uqer.io/community/share/54d83bb3f9f06c276f651a6e
NumPy替我们搞定了向量和矩阵的相关操作，基本上算是一个高级的科学计算器。SciPy基于NumPy提供了更为丰富和高级的功能扩展，在统计、优化、插值、数值积分、时频转换等方面提供了大量的可用函数，基本覆盖了基础科学计算相关的问题。
在量化分析中，运用最广泛的是统计">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="http://dn-cyfall.qbox.me/%E5%A4%B4%E5%83%8F.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://dn-cyfall.qbox.me/%E5%A4%B4%E5%83%8F.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">John Doe</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/chenyuntc" title="github">github</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/cloudfall" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="mailto:i@knew.be" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/IO编程/" style="font-size: 11.43px;">IO编程</a> <a href="/tags/android/" style="font-size: 10px;">android</a> <a href="/tags/deepLearning/" style="font-size: 10px;">deepLearning</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/git/" style="font-size: 12.86px;">git</a> <a href="/tags/java/" style="font-size: 14.29px;">java</a> <a href="/tags/linux/" style="font-size: 18.57px;">linux</a> <a href="/tags/machineLearning/" style="font-size: 10px;">machineLearning</a> <a href="/tags/markdown/" style="font-size: 12.86px;">markdown</a> <a href="/tags/math/" style="font-size: 12.86px;">math</a> <a href="/tags/mathjax/" style="font-size: 10px;">mathjax</a> <a href="/tags/matplotlib/" style="font-size: 10px;">matplotlib</a> <a href="/tags/numpy/" style="font-size: 10px;">numpy</a> <a href="/tags/pandas/" style="font-size: 11.43px;">pandas</a> <a href="/tags/pandoc/" style="font-size: 10px;">pandoc</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/scipy/" style="font-size: 10px;">scipy</a> <a href="/tags/spark/" style="font-size: 10px;">spark</a> <a href="/tags/tips/" style="font-size: 10px;">tips</a> <a href="/tags/内存管理/" style="font-size: 11.43px;">内存管理</a> <a href="/tags/函数式编程/" style="font-size: 15.71px;">函数式编程</a> <a href="/tags/反编译/" style="font-size: 10px;">反编译</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/多进程/" style="font-size: 10px;">多进程</a> <a href="/tags/安全/" style="font-size: 10px;">安全</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/机器学习/" style="font-size: 17.14px;">机器学习</a> <a href="/tags/测试/" style="font-size: 10px;">测试</a> <a href="/tags/深度学习/" style="font-size: 10px;">深度学习</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/面向对象编程/" style="font-size: 11.43px;">面向对象编程</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/vamei">vamei博客园</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">亦正亦邪</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">John Doe</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://dn-cyfall.qbox.me/%E5%A4%B4%E5%83%8F.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">John Doe</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/chenyuntc" title="github">github</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/cloudfall" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="mailto:i@knew.be" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-scipy-指南" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/23/scipy-指南/" class="article-date">
  	<time datetime="2015-10-23T10:12:34.000Z" itemprop="datePublished">2015-10-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      scipy-指南
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scipy/">scipy</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/机器学习/">机器学习</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="scipy"><a href="#scipy" class="headerlink" title="scipy"></a>scipy</h1><p>原文 : <a href="https://uqer.io/community/share/54d83bb3f9f06c276f651a6e" target="_blank" rel="external">https://uqer.io/community/share/54d83bb3f9f06c276f651a6e</a></p>
<p>NumPy替我们搞定了向量和矩阵的相关操作，基本上算是一个高级的科学计算器。SciPy基于NumPy提供了更为丰富和高级的功能扩展，在统计、优化、插值、数值积分、时频转换等方面提供了大量的可用函数，基本覆盖了基础科学计算相关的问题。</p>
<p>在量化分析中，运用最广泛的是统计和优化的相关技术<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import numpy as np</div><div class="line">import scipy.stats as stats</div><div class="line">import scipy.optimize as opt</div></pre></td></tr></table></figure></p>
<h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><p>###　生成随机数<br>生成n个随机数可用rv_continuous.rvs(size=n)或rv_discrete.rvs(size=n)，其中rv_continuous表示连续型的随机分布，如均匀分布（uniform）、正态分布（norm）、贝塔分布（beta）等；rv_discrete表示离散型的随机分布，如伯努利分布（bernoulli）、几何分布（geom）、泊松分布（poisson）等。我们生成10个[0, 1]区间上的随机数和10个服从参数a=4，b=2的贝塔分布随机数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rv_unif = stats.uniform.rvs(size=<span class="number">10</span>)</div><div class="line"><span class="keyword">print</span> rv_unif</div><div class="line">rv_beta = stats.beta.rvs(size=<span class="number">10</span>, a=<span class="number">4</span>, b=<span class="number">2</span>)</div><div class="line"><span class="keyword">print</span> rv_beta</div></pre></td></tr></table></figure></p>
<p>在每个随机分布的生成函数里，都内置了默认的参数，如均匀分布的上下界默认是0和1。可是一旦需要修改这些参数，每次生成随机都要敲这么老长一串有点麻烦，能不能简单点？SciPy里头有一个Freezing的功能，可以提供简便版本的命令。SciPy.stats支持定义出某个具体的分布的对象，我们可以做如下的定义，让beta直接指代具体参数a=4和b=2的贝塔分布。为让结果具有可比性，这里指定了随机数的生成种子，由NumPy提供。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">np.random.seed(seed=<span class="number">2015</span>)</div><div class="line">rv_beta = stats.beta.rvs(size=<span class="number">10</span>, a=<span class="number">4</span>, b=<span class="number">2</span>)</div><div class="line"><span class="keyword">print</span> <span class="string">"method 1:"</span></div><div class="line"><span class="keyword">print</span> rv_beta</div><div class="line"></div><div class="line">np.random.seed(seed=<span class="number">2015</span>)</div><div class="line">beta = stats.beta(a=<span class="number">4</span>, b=<span class="number">2</span>)</div><div class="line"><span class="keyword">print</span> <span class="string">"method 2:"</span></div><div class="line"><span class="keyword">print</span> beta.rvs(size=<span class="number">10</span>)</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">stat_val, p_val = stats.kstest(dat, <span class="string">'norm'</span>, (mu, sigma))</div><div class="line"><span class="keyword">print</span> <span class="string">'KS-statistic D = %6.3f p-value = %6.4f'</span> % (stat_val, p_val)</div></pre></td></tr></table></figure>
<p>假设这个数据是我们获取到的实际的某些数据，如股票日涨跌幅，我们对数据进行简单的分析。最简单的是检验这一组数据是否服从假设的分布，如正态分布。这个问题是典型的单样本假设检验问题，最为常见的解决方案是采用K-S检验（ Kolmogorov-Smirnov test）。单样本K-S检验的原假设是给定的数据来自和原假设分布相同的分布，在SciPy中提供了kstest函数，参数分别是数据、拟检验的分布名称和对应的参数</p>
<h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><h4 id="cdf和pdf"><a href="#cdf和pdf" class="headerlink" title="cdf和pdf"></a>cdf和pdf</h4><p>PDF是概率密度（函数）<br>CDF是（累积）分布函数<br>有时需要知道某数值在一个分布中的分位，或者给定了一个分布，求某分位上的数值。这可以通过cdf和ppf函数完成：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">g_dist = stats.gamma(a=<span class="number">2</span>)</div><div class="line"><span class="keyword">print</span> <span class="string">"quantiles of 2, 4 and 5:"</span></div><div class="line"><span class="keyword">print</span> g_dist.cdf([<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>])</div><div class="line"><span class="keyword">print</span> <span class="string">"Values of 25%, 50% and 90%:"</span></div><div class="line"><span class="keyword">print</span> g_dist.pdf([<span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.95</span>])</div></pre></td></tr></table></figure></p>
<h4 id="describe"><a href="#describe" class="headerlink" title="describe"></a>describe</h4><p>describe函数提供对数据集的统计描述分析，包括数据样本大小，极值，均值，方差，偏度和峰度：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">norm_dist = stats.norm(loc=<span class="number">0</span>, scale=<span class="number">1.8</span>)</div><div class="line">dat = norm_dist.rvs(size=<span class="number">100</span>)</div><div class="line">info = stats.describe(dat)</div><div class="line"><span class="keyword">print</span> <span class="string">"Data size is: "</span> + str(info[<span class="number">0</span>])</div><div class="line"><span class="keyword">print</span> <span class="string">"Minimum value is: "</span> + str(info[<span class="number">1</span>][<span class="number">0</span>])</div><div class="line"><span class="keyword">print</span> <span class="string">"Maximum value is: "</span> + str(info[<span class="number">1</span>][<span class="number">1</span>])</div><div class="line"><span class="keyword">print</span> <span class="string">"Arithmetic mean is: "</span> + str(info[<span class="number">2</span>])</div><div class="line"><span class="keyword">print</span> <span class="string">"Unbiased variance is: "</span> + str(info[<span class="number">3</span>])</div><div class="line"><span class="keyword">print</span> <span class="string">"Biased skewness is: "</span> + str(info[<span class="number">4</span>])</div><div class="line"><span class="keyword">print</span> <span class="string">"Biased kurtosis is: "</span> + str(info[<span class="number">5</span>])</div></pre></td></tr></table></figure>
<h4 id="moment"><a href="#moment" class="headerlink" title="moment"></a>moment</h4><p>对于一个给定的分布，可以用moment很方便的查看分布的矩信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stats.norm.moment(6, loc=0, scale=1)</div></pre></td></tr></table></figure>
<h4 id="fit"><a href="#fit" class="headerlink" title="fit"></a>fit</h4><p>们知道一组数据服从某些分布的时候，可以调用fit函数来得到对应分布参数的极大似然估计（MLE, maximum-likelihood estimation）。以下代码示例了假设数据服从正态分布，用极大似然估计分布参数</p>
<h4 id="pearsonr和spearmanr"><a href="#pearsonr和spearmanr" class="headerlink" title="pearsonr和spearmanr"></a>pearsonr和spearmanr</h4><p>pearsonr和spearmanr可以计算Pearson和Spearman相关系数，这两个相关系数度量了两组数据的相互线性关联程度[^相关系数]<br>[^相关系数]: pearson相关和 spearman 的区别 <a href="http://blog.sina.com.cn/s/blog_497b91d70101h41b.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_497b91d70101h41b.html</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cor, pval = stats.pearsonr(dat1, dat2)</div><div class="line"><span class="keyword">print</span> <span class="string">"Pearson correlation coefficient: "</span> + str(cor)</div><div class="line">cor, pval = stats.pearsonr(dat1, dat2)</div><div class="line"><span class="keyword">print</span> <span class="string">"Spearman's rank correlation coefficient: "</span> + str(cor)</div></pre></td></tr></table></figure></p>
<h4 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">x = stats.chi2.rvs(<span class="number">3</span>, size=<span class="number">50</span>)</div><div class="line">y = <span class="number">2.5</span> + <span class="number">1.2</span> * x + stats.norm.rvs(size=<span class="number">50</span>, loc=<span class="number">0</span>, scale=<span class="number">1.5</span>)</div><div class="line">slope, intercept, r_value, p_value, std_err = stats.linregress(x, y)</div><div class="line"><span class="keyword">print</span> <span class="string">"Slope of fitted model is:"</span> , slope</div><div class="line"><span class="keyword">print</span> <span class="string">"Intercept of fitted model is:"</span>, intercept</div><div class="line"><span class="keyword">print</span> <span class="string">"R-squared:"</span>, r_value**<span class="number">2</span></div></pre></td></tr></table></figure>
<p>在<a href="http://wiki.scipy.org/" target="_blank" rel="external">官方wiki</a>，可以查到大部分stat中的函数，本节权作简单介绍，挖掘更多功能的最好方法还是直接读原始的文档。另外，<a href="http://statsmodels.sourceforge.net" target="_blank" rel="external">StatsModels</a>模块提供了更为专业，更多的统计相关函数。若在SciPy没有满足需求，可以采用StatsModels。</p>
<h2 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h2><h3 id="无约束优化问题"><a href="#无约束优化问题" class="headerlink" title="无约束优化问题"></a>无约束优化问题</h3><p>作为寻优的目标函数来简要介绍在SciPy中使用优化模块scipy.optimize。<br>首先需要定义一下这个Rosenbrock函数：<br>$$\sum_0^{N-1}100(x<em>i-x</em>{i-1}^2)^2+(1-x_{i-1})^2$$<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">rosen</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="string">"""The Rosenbrock function"""</span></div><div class="line">    <span class="keyword">return</span> sum(<span class="number">100.0</span>*(x[<span class="number">1</span>:]-x[:<span class="number">-1</span>]**<span class="number">2.0</span>)**<span class="number">2.0</span> + (<span class="number">1</span>-x[:<span class="number">-1</span>])**<span class="number">2.0</span>)</div></pre></td></tr></table></figure></p>
<h4 id="Nelder-Mead单纯形法"><a href="#Nelder-Mead单纯形法" class="headerlink" title="Nelder-Mead单纯形法"></a>Nelder-Mead单纯形法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x_0 = np.array([<span class="number">0.5</span>, <span class="number">1.6</span>, <span class="number">1.1</span>, <span class="number">0.8</span>, <span class="number">1.2</span>])</div><div class="line">res = opt.minimize(rosen, x_0, method=<span class="string">'nelder-mead'</span>, options=&#123;<span class="string">'xtol'</span>: <span class="number">1e-8</span>, <span class="string">'disp'</span>: <span class="keyword">True</span>&#125;)</div><div class="line"><span class="keyword">print</span> <span class="string">"Result of minimizing Rosenbrock function via Nelder-Mead Simplex algorithm:"</span></div><div class="line"><span class="keyword">print</span> res</div></pre></td></tr></table></figure>
<p>Rosenbrock函数的性质比较好，简单的优化方法就可以处理了，还可以在minimize中使用method=’powell’来指定使用Powell’s method。这两种简单的方法并不使用函数的梯度，在略微复杂的情形下收敛速度比较慢，下面让我们来看一下用到函数梯度进行寻优的方法。</p>
<h4 id="Broyden-Fletcher-Goldfarb-Shanno法-BFGS"><a href="#Broyden-Fletcher-Goldfarb-Shanno法-BFGS" class="headerlink" title="Broyden-Fletcher-Goldfarb-Shanno法(BFGS)"></a>Broyden-Fletcher-Goldfarb-Shanno法(BFGS)</h4><p>（BFGS）法用到了梯度信息，首先求一下Rosenbrock函数的梯度：<br>$$<br>{\partial f \over \partial x_j} =  200(x<em>j-x</em>{j-1}^2)   - 400 x<em>j(x</em>{j+1}   -   x_j^2)-2*(1-x_j)$$</p>
<p>边界的梯度是特例<br>$$<br>{\partial f \over \partial x_0} = - 400 x<em>j(x</em>{1}   -   x_0^2)-2*(1-x<em>0)\<br>{\partial f \over \partial N-1} =  200(x</em>{N-1}-x_{N-2}^2)<br>$$<br>们可以如下定义梯度向量的计算函数了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">rosen_der</span><span class="params">(x)</span>:</span></div><div class="line">    xm = x[<span class="number">1</span>:<span class="number">-1</span>]</div><div class="line">    xm_m1 = x[:<span class="number">-2</span>]</div><div class="line">    xm_p1 = x[<span class="number">2</span>:]</div><div class="line">    der = np.zeros_like(x)</div><div class="line">    der[<span class="number">1</span>:<span class="number">-1</span>] = <span class="number">200</span>*(xm-xm_m1**<span class="number">2</span>) - <span class="number">400</span>*(xm_p1 - xm**<span class="number">2</span>)*xm - <span class="number">2</span>*(<span class="number">1</span>-xm)</div><div class="line">    der[<span class="number">0</span>] = <span class="number">-400</span>*x[<span class="number">0</span>]*(x[<span class="number">1</span>]-x[<span class="number">0</span>]**<span class="number">2</span>) - <span class="number">2</span>*(<span class="number">1</span>-x[<span class="number">0</span>])</div><div class="line">    der[<span class="number">-1</span>] = <span class="number">200</span>*(x[<span class="number">-1</span>]-x[<span class="number">-2</span>]**<span class="number">2</span>)</div><div class="line">    <span class="keyword">return</span> der</div></pre></td></tr></table></figure></p>
<p>梯度信息的引入在minimize函数中通过参数jac指定：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">res = opt.minimize(rosen, x_0, method=<span class="string">'BFGS'</span>, jac=rosen_der, options=&#123;<span class="string">'disp'</span>: <span class="keyword">True</span>&#125;)</div><div class="line"><span class="keyword">print</span> <span class="string">"Result of minimizing Rosenbrock function via Broyden-Fletcher-Goldfarb-Shanno algorithm:"</span></div><div class="line"><span class="keyword">print</span> res</div></pre></td></tr></table></figure></p>
<h4 id="牛顿共轭梯度法"><a href="#牛顿共轭梯度法" class="headerlink" title="牛顿共轭梯度法"></a>牛顿共轭梯度法</h4><p>用到梯度的方法还有牛顿法，牛顿法是收敛速度最快的方法，其缺点在于要求Hessian矩阵（二阶导数矩阵）。牛顿法大致的思路是采用泰勒展开的二阶近似：<br>$$<br>f(x) \approx f(x_0)+\nabla f(x_0)(x-x_0) + \frac12(x-x_0)^TH(x_0)(x-x<em>0)<br>$$<br>若Hessian矩阵是正定的，函数的局部最小值可以通过使上面的<strong>二次型的一阶导数</strong>等于0来获取，我们有:<br>$$<br>x</em>{opt} = x_0-H^{-1}\nabla f<br>$$<br><strong>这里可使用共轭梯度近似</strong>Hessian矩阵的逆矩阵。<br> 为使用牛顿共轭梯度法，我们需要提供一个计算Hessian矩阵的函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">rosen_hess</span><span class="params">(x)</span>:</span></div><div class="line">   x = np.asarray(x)</div><div class="line">   H = np.diag(<span class="number">-400</span>*x[:<span class="number">-1</span>],<span class="number">1</span>) - np.diag(<span class="number">400</span>*x[:<span class="number">-1</span>],<span class="number">-1</span>)</div><div class="line">   diagonal = np.zeros_like(x)</div><div class="line">   diagonal[<span class="number">0</span>] = <span class="number">1200</span>*x[<span class="number">0</span>]**<span class="number">2</span><span class="number">-400</span>*x[<span class="number">1</span>]+<span class="number">2</span></div><div class="line">   diagonal[<span class="number">-1</span>] = <span class="number">200</span></div><div class="line">   diagonal[<span class="number">1</span>:<span class="number">-1</span>] = <span class="number">202</span> + <span class="number">1200</span>*x[<span class="number">1</span>:<span class="number">-1</span>]**<span class="number">2</span> - <span class="number">400</span>*x[<span class="number">2</span>:]</div><div class="line">   H = H + np.diag(diagonal)</div><div class="line">   <span class="keyword">return</span> H</div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">res = opt.minimize(rosen, x_0, method=<span class="string">'Newton-CG'</span>, jac=rosen_der, hess=rosen_hess, options=&#123;<span class="string">'xtol'</span>: <span class="number">1e-8</span>, <span class="string">'disp'</span>: <span class="keyword">True</span>&#125;)</div><div class="line"><span class="keyword">print</span> <span class="string">"Result of minimizing Rosenbrock function via Newton-Conjugate-Gradient algorithm (Hessian):"</span></div><div class="line"><span class="keyword">print</span> res</div></pre></td></tr></table></figure>
<p>对于一些大型的优化问题，Hessian矩阵将异常大，牛顿共轭梯度法用到的仅是Hessian矩阵和一个任意向量的乘积，为此，用户可以提供两个向量，一个是Hessian矩阵和一个任意向量p的乘积，另一个是向量p，这就减少了存储的开销。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">rosen_hess_p</span><span class="params">(x, p)</span>:</span></div><div class="line">    x = np.asarray(x)</div><div class="line">    Hp = np.zeros_like(x)</div><div class="line">    Hp[<span class="number">0</span>] = (<span class="number">1200</span>*x[<span class="number">0</span>]**<span class="number">2</span> - <span class="number">400</span>*x[<span class="number">1</span>] + <span class="number">2</span>)*p[<span class="number">0</span>] - <span class="number">400</span>*x[<span class="number">0</span>]*p[<span class="number">1</span>]</div><div class="line">    Hp[<span class="number">1</span>:<span class="number">-1</span>] = <span class="number">-400</span>*x[:<span class="number">-2</span>]*p[:<span class="number">-2</span>]+(<span class="number">202</span>+<span class="number">1200</span>*x[<span class="number">1</span>:<span class="number">-1</span>]**<span class="number">2</span><span class="number">-400</span>*x[<span class="number">2</span>:])*p[<span class="number">1</span>:<span class="number">-1</span>] \</div><div class="line">               <span class="number">-400</span>*x[<span class="number">1</span>:<span class="number">-1</span>]*p[<span class="number">2</span>:]</div><div class="line">    Hp[<span class="number">-1</span>] = <span class="number">-400</span>*x[<span class="number">-2</span>]*p[<span class="number">-2</span>] + <span class="number">200</span>*p[<span class="number">-1</span>]</div><div class="line">    <span class="keyword">return</span> Hp</div><div class="line"></div><div class="line">res = opt.minimize(rosen, x_0, method=<span class="string">'Newton-CG'</span>, jac=rosen_der, hessp=rosen_hess_p, options=&#123;<span class="string">'xtol'</span>: <span class="number">1e-8</span>, <span class="string">'disp'</span>: <span class="keyword">True</span>&#125;)</div><div class="line"><span class="keyword">print</span> <span class="string">"Result of minimizing Rosenbrock function via Newton-Conjugate-Gradient algorithm (Hessian times arbitrary vector):"</span></div><div class="line"><span class="keyword">print</span> res</div></pre></td></tr></table></figure></p>
<h2 id="约束优化问题"><a href="#约束优化问题" class="headerlink" title="约束优化问题"></a>约束优化问题</h2><p>我们考察如下一个例子：<br>$$\begin{align}<br>min\quad    f(x,y)&amp;= 2xy+2x-x^2-2y^2\<br> s.t. \quad<br> x^3-y&amp;=0\<br>y-1&amp;\ge 0<br>\end{align}<br>$$</p>
<p>定义目标函数及其导数为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x, sign=<span class="number">1.0</span>)</span>:</span></div><div class="line">    <span class="string">""" Objective function """</span></div><div class="line">    <span class="keyword">return</span> sign*(<span class="number">2</span>*x[<span class="number">0</span>]*x[<span class="number">1</span>] + <span class="number">2</span>*x[<span class="number">0</span>] - x[<span class="number">0</span>]**<span class="number">2</span> - <span class="number">2</span>*x[<span class="number">1</span>]**<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_deriv</span><span class="params">(x, sign=<span class="number">1.0</span>)</span>:</span></div><div class="line">    <span class="string">""" Derivative of objective function """</span></div><div class="line">    dfdx0 = sign*(<span class="number">-2</span>*x[<span class="number">0</span>] + <span class="number">2</span>*x[<span class="number">1</span>] + <span class="number">2</span>)</div><div class="line">    dfdx1 = sign*(<span class="number">2</span>*x[<span class="number">0</span>] - <span class="number">4</span>*x[<span class="number">1</span>])</div><div class="line">    <span class="keyword">return</span> np.array([ dfdx0, dfdx1 ])</div></pre></td></tr></table></figure></p>
<p>其中sign表示求解最小或者最大值+1 最小值,-1 最大值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cons = (&#123;<span class="string">'type'</span>: <span class="string">'eq'</span>,  <span class="string">'fun'</span>: <span class="keyword">lambda</span> x: np.array([x[<span class="number">0</span>]**<span class="number">3</span> - x[<span class="number">1</span>]]), <span class="string">'jac'</span>: <span class="keyword">lambda</span> x: np.array([<span class="number">3.0</span>*(x[<span class="number">0</span>]**<span class="number">2.0</span>), <span class="number">-1.0</span>])&#125;,</div><div class="line">      &#123;<span class="string">'type'</span>: <span class="string">'ineq'</span>, <span class="string">'fun'</span>: <span class="keyword">lambda</span> x: np.array([x[<span class="number">1</span>] - <span class="number">1</span>]), <span class="string">'jac'</span>: <span class="keyword">lambda</span> x: np.array([<span class="number">0.0</span>, <span class="number">1.0</span>])&#125;)</div><div class="line">  res = opt.minimize(func, [<span class="number">-1.0</span>, <span class="number">1.0</span>], args=(<span class="number">-1.0</span>,), jac=func_deriv, method=<span class="string">'SLSQP'</span>, options=&#123;<span class="string">'disp'</span>: <span class="keyword">True</span>&#125;)</div><div class="line"><span class="keyword">print</span> <span class="string">"Result of unconstrained optimization:"</span></div><div class="line"><span class="keyword">print</span> res</div><div class="line">res = opt.minimize(func, [<span class="number">-1.0</span>, <span class="number">1.0</span>], args=(<span class="number">-1.0</span>,), jac=func_deriv, constraints=cons, method=<span class="string">'SLSQP'</span>, options=&#123;<span class="string">'disp'</span>: <span class="keyword">True</span>&#125;)</div><div class="line"><span class="keyword">print</span> <span class="string">"Result of constrained optimization:"</span></div><div class="line"><span class="keyword">print</span> res</div></pre></td></tr></table></figure>
<p>更详细的minimize函数使用方法<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html#scipy-optimize-minimize" target="_blank" rel="external">见此</a></p>
<p>和统计部分一样，Python也有专门的优化扩展模块，CVXOPT（<a href="http://cvxopt.org" target="_blank" rel="external">http://cvxopt.org</a> ）专门用于处理凸优化问题，在约束优化问题上提供了更多的备选方法。CVXOPT是著名的凸优化教材convex optimization的作者之一，加州大学洛杉矶分校Lieven Vandenberghe教授的大作，是处理优化问题的利器。</p>
<p>SciPy中的优化模块还有一些特殊定制的函数，专门处理能够转化为优化求解的一些问题，如方程求根、最小方差拟合等，可到SciPy优化部分的指引页面查看。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/10/23/pandas-指南-2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          pandas-指南-2
        
      </div>
    </a>
  
  
    <a href="/2015/10/23/pandas-指南/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">pandas-指南</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="scipy-指南" data-title="scipy-指南" data-url="http://yoursite.com/2015/10/23/scipy-指南/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 John Doe
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>